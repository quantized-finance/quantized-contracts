{
  "language": "Solidity",
  "sources": {
    "src/sets/AddressSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n/**\n * @notice Key sets with enumeration and delete. Uses mappings for random\n * and existence checks and dynamic arrays for enumeration. Key uniqueness is enforced.\n * @dev Sets are unordered. Delete operations reorder keys. All operations have a\n * fixed gas cost at any scale, O(1).\n * author: Rob Hitchens\n */\n\nlibrary AddressSet {\n    struct Set {\n        mapping(address => uint256) keyPointers;\n        address[] keyList;\n    }\n\n    /**\n     * @notice insert a key.\n     * @dev duplicate keys are not permitted.\n     * @param self storage pointer to a Set.\n     * @param key value to insert.\n     */\n    function insert(Set storage self, address key) internal {\n        require(!exists(self, key), \"AddressSet: key already exists in the set.\");\n        self.keyList.push(key);\n        self.keyPointers[key] = self.keyList.length - 1;\n    }\n\n    /**\n     * @notice remove a key.\n     * @dev key to remove must exist.\n     * @param self storage pointer to a Set.\n     * @param key value to remove.\n     */\n    function remove(Set storage self, address key) internal {\n        require(exists(self, key), \"AddressSet: key does not exist in the set.\");\n        uint256 last = count(self) - 1;\n        uint256 rowToReplace = self.keyPointers[key];\n        if (rowToReplace != last) {\n            address keyToMove = self.keyList[last];\n            self.keyPointers[keyToMove] = rowToReplace;\n            self.keyList[rowToReplace] = keyToMove;\n        }\n        delete self.keyPointers[key];\n        delete self.keyList[self.keyList.length - 1];\n    }\n\n    /**\n     * @notice count the keys.\n     * @param self storage pointer to a Set.\n     */\n    function count(Set storage self) internal view returns (uint256) {\n        return (self.keyList.length);\n    }\n\n    /**\n     * @notice check if a key is in the Set.\n     * @param self storage pointer to a Set.\n     * @param key value to check.\n     * @return bool true: Set member, false: not a Set member.\n     */\n    function exists(Set storage self, address key) internal view returns (bool) {\n        if (self.keyList.length == 0) return false;\n        return self.keyList[self.keyPointers[key]] == key;\n    }\n\n    /**\n     * @notice fetch a key by row (enumerate).\n     * @param self storage pointer to a Set.\n     * @param index row to enumerate. Must be < count() - 1.\n     */\n    function keyAtIndex(Set storage self, uint256 index) internal view returns (address) {\n        return self.keyList[index];\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}